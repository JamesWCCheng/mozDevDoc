## Prerequisite

Before implementing XPCOM components, 
you need to get the firefox source code, 
which is known as **mozilla-central**, from Mercurial or Git.
The path of mozilla-central is denoted by **MOZ_CEN** from here.

- MDN : https://developer.mozilla.org/en-US/docs/Mozilla/Developer_guide/Source_Code/Mercurial
- Mercurial Menual : https://developer.mozilla.org/en-US/docs/Mozilla/Developer_guide/Source_Code/Mercurial
- Mercurial : https://hg.mozilla.org/mozilla-central/
- Git : https://github.com/mozilla/mozilla-central


## Terminology

- MOZ_CEN


## Concept


## Playing the existing XPCOM sample

There is an existing sample code for XPCOM component 
whose interface is **nsISample**.
The code is in **MOZ_CEN/xpcom/sample**.
You should see all the code in this dictionary(Look nsISample.idl first).
Take **nsSample.h** as an example here:

<pre>
$ vim MOZ_CEN/xpcom/sample/nsSample.h
</pre>

```cpp
#include "nsISample.h"
#include "mozilla/Attributes.h"

/**
 * SampleImpl is an implementation of the nsISample interface.  In XPCOM,
 * there can be more than one implementation of an given interface.  Class
 * IDs (CIDs) uniquely identify a particular implementation of an interface.
 * Interface IDs (IIDs) uniquely identify an interface.
 *
 * The CID is also a unique number that looks just like an IID
 * and uniquely identifies an implementation
 * {7CB5B7A0-07D7-11d3-BDE2-000064657374}
 */

#define NS_SAMPLE_CID \
{ 0x7cb5b7a0, 0x7d7, 0x11d3, { 0xbd, 0xe2, 0x0, 0x0, 0x64, 0x65, 0x73, 0x74 } }

#define NS_SAMPLE_CONTRACTID "@mozilla.org/sample;1"


class nsSampleImpl MOZ_FINAL : public nsISample
{
public:
  nsSampleImpl();
...
...
}

...
...

```


- Run the **nsISample** XPCOM component

  - If you never built mozilla-central before
<pre>
$ ./mach build or ./mach build/ xpcom/
</pre>

  - Play it in **xpcshell**
<pre>
$ cd obj-YOUR-TARGET-XXXX/dist/bin
$ ./run-mozilla.sh ./xpcshell
</pre>

<pre>
js> const cSample = new Components.Constructor("@mozilla.org/sample;1", "nsISample");
js> var sample = new cSample(); 
js> sample.writeValue("Hello")
Hello initial value
foopy 5
GetValue 8
js> sample.value
initial value
js> sample.poke("nice to see you")
js> sample.value
nice to see you
js> sample.writeValue("yo!man!")
yo!man! nice to see you
foopy 5
GetValue 8
js> sample.value
nice to see you
js> sample.poke("high five");
js> sample.value
high five
js> sample.writeValue("yo!man!");
yo!man! high five
foopy 5
GetValue 8
js> quit()
</pre>
  

## Creating your own XPCOM component

### Making a dictionay for this XPCOM component
<pre>
$ cd MOZ_CEN/xpcom/
$ mkdir sample2
</pre>

### Exposing the dictionary created to mozilla build system
<pre>
$ vim moz.build
</pre>

```
..
..
if CONFIG['OS_ARCH'] == 'WINNT' and CONFIG['MOZ_DEBUG']:
    DIRS += ['windbgdlg']

TEST_DIRS += [
    'tests',
    'sample',
    'sample2',
    'typelib/xpt/tests',
]

#Can not build internal xptcall tests that use symbols which are not exported.
#TEST_DIRS += [
..
..

```

### Writing a IDL file for your XPCOM component
#### Generating a UUID as your XPCOM component ID
<pre>
$ uuidgen
0390037d-9ca2-4d68-b998-4a4245b4d118
</pre>

#### Writing IDL for XPCOM component
<pre>
$ vim nsITest.idl
</pre>

```
#include "nsISupports.idl"
[scriptable, uuid(0390037d-9ca2-4d68-b998-4a4245b4d118)]
interface nsITest : nsISupports
{
    attribute string value;
    void writeValue(in string aPrefix);
    long add(in long a, in long b);
    long sub(in long a, in long b);
    long mul(in long a, in long b);
};

```
  the number in uuid is generated by previous step.

### Generating the interface and implementation template from the IDL

First, you need to write a file for build system:
<pre>
$ vim moz.build
</pre>

```
# XPIDL_SOURCES specifies IDL files. The build system runs the xpidl tool
# on these files to generate C++ headers and .xpt typelib files.
XPIDL_SOURCES += ['nsITest.idl']

# XPIDL_MODULE specifies where header files from this Makefile are installed,
# i.e. dist/include/xpcomsample
XPIDL_MODULE = 'xpcomtest'
```

Then, you can generate the interface and template for your XPCOM component.
<pre>
$ cd MOZ_CEN
$ ./mach build
</pre>


After building, the interface of your XPCOM componenet 
will be in **MOZ_CEN/obj-xxxxx/dist/include** folder.
You will see **nsITest.h** there. 
This file is an interface of your XPCOM componenet, 
and the template of its implementation is in the comment of it.
<pre>
$ vim MOZ_CEN/obj-xxxxx/dist/include/nsITest.h 
</pre>

```cpp
/*
 * DO NOT EDIT.  THIS FILE IS GENERATED FROM ../../../dist/idl/nsITest.idl
 */

#ifndef __gen_nsITest_h__
#define __gen_nsITest_h__


#ifndef __gen_nsISupports_h__
#include "nsISupports.h"
#endif

/* For IDL files that don't want to include root IDL files. */
#ifndef NS_NO_VTABLE
#define NS_NO_VTABLE
#endif

/* starting interface:    nsITest */
#define NS_ITEST_IID_STR "0390037d-9ca2-4d68-b998-4a4245b4d118"

#define NS_ITEST_IID \
  {0x0390037d, 0x9ca2, 0x4d68, \
    { 0xb9, 0x98, 0x4a, 0x42, 0x45, 0xb4, 0xd1, 0x18 }}

class NS_NO_VTABLE nsITest : public nsISupports {
 public: 

  NS_DECLARE_STATIC_IID_ACCESSOR(NS_ITEST_IID)

  /* attribute string value; */
  NS_IMETHOD GetValue(char * *aValue) = 0;
  NS_IMETHOD SetValue(const char * aValue) = 0;

  /* void writeValue (in string aPrefix); */
  NS_IMETHOD WriteValue(const char * aPrefix) = 0;

  /* long add (in long a, in long b); */
  NS_IMETHOD Add(int32_t a, int32_t b, int32_t *_retval) = 0;

  /* long sub (in long a, in long b); */
  NS_IMETHOD Sub(int32_t a, int32_t b, int32_t *_retval) = 0;

  /* long mul (in long a, in long b); */
  NS_IMETHOD Mul(int32_t a, int32_t b, int32_t *_retval) = 0;

};

...
...

#if 0
/* Use the code below as a template for the implementation class for this interface. */

/* Header file */
class nsTest : public nsITest
{
public:
  NS_DECL_ISUPPORTS
  NS_DECL_NSITEST

  nsTest();

private:
  ~nsTest();

protected:
  /* additional members */
};

/* Implementation file */
NS_IMPL_ISUPPORTS(nsTest, nsITest)

nsTest::nsTest()
{
  /* member initializers and constructor code */
}

nsTest::~nsTest()
{
  /* destructor code */
}

/* attribute string value; */
NS_IMETHODIMP nsTest::GetValue(char * *aValue)
{
    return NS_ERROR_NOT_IMPLEMENTED;
}
NS_IMETHODIMP nsTest::SetValue(const char * aValue)
{
    return NS_ERROR_NOT_IMPLEMENTED;
}

/* void writeValue (in string aPrefix); */
NS_IMETHODIMP nsTest::WriteValue(const char * aPrefix)
{
    return NS_ERROR_NOT_IMPLEMENTED;
}

/* long add (in long a, in long b); */
NS_IMETHODIMP nsTest::Add(int32_t a, int32_t b, int32_t *_retval)
{
    return NS_ERROR_NOT_IMPLEMENTED;
}

/* long sub (in long a, in long b); */
NS_IMETHODIMP nsTest::Sub(int32_t a, int32_t b, int32_t *_retval)
{
    return NS_ERROR_NOT_IMPLEMENTED;
}

/* long mul (in long a, in long b); */
NS_IMETHODIMP nsTest::Mul(int32_t a, int32_t b, int32_t *_retval)
{
    return NS_ERROR_NOT_IMPLEMENTED;
}

/* End of implementation class template. */
#endif

#endif /* __gen_nsITest_h__ */
```

The template of .h and .cpp is in comment 
*Header file* and *Implementation file*.


### Implementing your XPCOM component from the template

Creating a .h file in **sample2** folder and completing your code from
the template /* Header file*/ in nsITest.h
<pre>
$ vim nsTest.h 
</pre>

```cpp
#ifndef nsTest_h
#define nsTest_h

/**
 * This file is the header of an implementation nsTest of the nsITest interface.
 */

#include "nsITest.h"
#include "mozilla/Attributes.h"

/**
 * TestImpl is an implementation of the nsITest interface.  In XPCOM,
 * there can be more than one implementation of an given interface.  Class
 * IDs (CIDs) uniquely identify a particular implementation of an interface.
 * Interface IDs (IIDs) uniquely identify an interface.
 *
 * The CID is also a unique number that looks just like an IID
 * and uniquely identifies an implementation
 * {0390037d-9ca2-4d68-b998-4a4245b4d118}
 */

#define NS_TEST_CID \
{ 0x0390037d, 0x9ca2, 0x4d68, { 0xb9, 0x98, 0x4a, 0x42, 0x45, 0xb4, 0xd1, 0x18 } }

#define NS_TEST_CONTRACTID "@mozilla.org/test;1"


class nsTest : public nsITest
{
public:
  /**
   * This macro expands into a declaration of the nsISupports interface.
   * Every XPCOM component needs to implement nsISupports, as it acts
   * as the gateway to other interfaces this component implements.  You
   * could manually declare QueryInterface, AddRef, and Release instead
   * of using this macro, but why?
   */
  // nsISupports interface
  NS_DECL_ISUPPORTS

  /**
   * This macro is defined in the nsITest.h file, and is generated
   * automatically by the xpidl compiler.  It expands to
   * declarations of all of the methods required to implement the
   * interface.  xpidl will generate a NS_DECL_[INTERFACENAME] macro
   * for each interface that it processes.
   *
   * The methods of nsITest are discussed individually below, but
   * commented out (because this macro already defines them.)
   */
  NS_DECL_NSITEST

 /**
   * The following is an explanation of how the interface header
   * file expands to for a c++ implementation. NS_DELC_NSITEST
   * takes care of defining the right c++ implementation.
   *
   * The following if provided for more understanding.
   *
   * NS_IMETHOD expands to the standard XPCOM return type.  XPCOM methods
   * should never return any other type.  The return value is used
   * behind the scenes by the XPConnect runtime to figure out if the call
   * failed in any way.
   * These methods were generated by "attribute string Value" in
   * nsITest.idl.  When reflected into JavaScript, XPCOM will use these
   * calls as Getter/Setter ops, so that they can be called transparently
   * as "test.Value='foo';" and "var val = test.Value"
   */
  /* NS_IMETHOD GetValue(char** aValue); */
  /* NS_IMETHOD SetValue(char* aValue); */

  /**
   * The const came from the "in" specifier in nsITest.idl.  "in"
   * specifies that the value of this parameter is used only for input,
   * this method is not allowed to modify the contents of the buffer.
   */
  /* NS_IMETHOD WriteValue(const char* aPrefix); */

  /**
   * nsITest.idl specifies all of its string types as string, instead
   * of wstring (wide string), the Unicode type.  If the world were a
   * perfect place, all normal strings in XPCOM interfaces would be unicode.
   * If this type had been specified as wstring, it would appear as
   * char16_t * in C++, which is the NSPR type for unicode characters.
   */
  /* NS_IMETHOD Add(int32_t a, int32_t b, int32_t *_retval); */
  /* NS_IMETHOD Sub(int32_t a, int32_t b, int32_t *_retval); */
  /* NS_IMETHOD Mul(int32_t a, int32_t b, int32_t *_retval); */


  nsTest();

private:
  ~nsTest();

  char* mValue;

protected:
  /* additional members */
};
```

Next, writing the .cpp file

<pre>
$ vim nsTest.cpp 
</pre>

```cpp
/**
 * This file contains an implementation nsTest of the interface nsISample.
 */
#include <stdio.h>

#include "nsTest.h"
#include "nsMemory.h"

#include "nsEmbedString.h"
#include "nsIClassInfoImpl.h"
////////////////////////////////////////////////////////////////////////

nsTest::nsTest() : mValue(nullptr)
{
  mValue = (char*)nsMemory::Clone("hello world", 12);
  //12 = strlen("hello world") + strlen('\0') = 11 + 1
}

nsTest::~nsTest()
{
  if (mValue) {
    nsMemory::Free(mValue);
  }
}


/**
 * NS_IMPL_ISUPPORTS expands to a simple implementation of the nsISupports
 * interface.  This includes a proper implementation of AddRef, Release,
 * and QueryInterface.  If this class supported more interfaces than just
 * nsISupports,
 * you could use NS_IMPL_ADDREF() and NS_IMPL_RELEASE() to take care of the
 * simple stuff, but you would have to create QueryInterface on your own.
 * nsSampleFactory.cpp is an example of this approach.
 * Notice that the second parameter to the macro is name of the interface, and
 * NOT the #defined IID.
 *
 * The _CI variant adds support for nsIClassInfo, which permits introspection
 * and interface flattening.
 */
NS_IMPL_CLASSINFO(nsTest, nullptr, 0, NS_TEST_CID)
NS_IMPL_ISUPPORTS_CI(nsTest, nsITest)


/**
 * Notice that in the protoype for this function, the NS_IMETHOD macro was
 * used to declare the return type.  For the implementation, the return
 * type is declared by NS_IMETHODIMP
 */
NS_IMETHODIMP
nsTest::GetValue(char** aValue)
{
  NS_PRECONDITION(aValue != nullptr, "null ptr");
  if (!aValue) {
    return NS_ERROR_NULL_POINTER;
  }

  if (mValue) {
    /**
     * GetValue's job is to return data known by an instance of
     * nsSampleImpl to the outside world.  If we  were to simply return
     * a pointer to data owned by this instance, and the client were to
     * free it, bad things would surely follow.
     * On the other hand, if we create a new copy of the data for our
     * client, and it turns out that client is implemented in JavaScript,
     * there would be no way to free the buffer.  The solution to the
     * buffer ownership problem is the nsMemory singleton.  Any buffer
     * returned by an XPCOM method should be allocated by the nsMemory.
     * This convention lets things like JavaScript reflection do their
     * job, and simplifies the way C++ clients deal with returned buffers.
     */
    *aValue = (char*)nsMemory::Clone(mValue, strlen(mValue) + 1);
    if (!*aValue) {
      return NS_ERROR_NULL_POINTER;
    }
  } else {
    *aValue = nullptr;
  }
  return NS_OK;
}

NS_IMETHODIMP
nsTest::SetValue(const char* aValue)
{
  NS_PRECONDITION(aValue != nullptr, "null ptr");
  if (!aValue) {
    return NS_ERROR_NULL_POINTER;
  }

  if (mValue) {
    nsMemory::Free(mValue);
  }

  /**
   * Another buffer passing convention is that buffers passed INTO your
   * object ARE NOT YOURS.  Keep your hands off them, unless they are
   * declared "inout".  If you want to keep the value for posterity,
   * you will have to make a copy of it.
   */
  mValue = (char*)nsMemory::Clone(aValue, strlen(aValue) + 1);
  return NS_OK;
}

/* long add (in long a, in long b); */
NS_IMETHODIMP
nsTest::Add(int32_t a, int32_t b, int32_t *_retval)
{
    *_retval = a + b;
    return NS_OK;
}


/* long sub (in long a, in long b); */
NS_IMETHODIMP
nsTest::Sub(int32_t a, int32_t b, int32_t *_retval)
{
    *_retval = a - b;
    return NS_OK;
}


/* long mul (in long a, in long b); */
NS_IMETHODIMP
nsTest::Mul(int32_t a, int32_t b, int32_t *_retval)
{
    *_retval = a * b;
    return NS_OK;
}


static void
GetStringValue(nsACString& aValue)
{
  NS_CStringSetData(aValue, "GetValue");
}


/* void writeValue (in string aPrefix); */
NS_IMETHODIMP
nsTest::WriteValue(const char* aPrefix)
{
  NS_PRECONDITION(aPrefix != nullptr, "null ptr");
  if (!aPrefix) {
    return NS_ERROR_NULL_POINTER;
  }

  printf("%s %s\n", aPrefix, mValue);

  // This next part illustrates the nsEmbedString:
  nsEmbedString foopy;
  foopy.Append(char16_t('f'));
  foopy.Append(char16_t('o'));
  foopy.Append(char16_t('o'));
  foopy.Append(char16_t('p'));
  foopy.Append(char16_t('y'));

  const char16_t* f = foopy.get();
  uint32_t l = foopy.Length();
  printf("%c%c%c%c%c %d\n",
         char(f[0]), char(f[1]), char(f[2]), char(f[3]), char(f[4]), l);

  nsEmbedCString foopy2;
  GetStringValue(foopy2);

  //foopy2.AppendLiteral("foopy");
  const char* f2 = foopy2.get();
  uint32_t l2 = foopy2.Length();

  printf("%s %d\n", f2, l2);

  return NS_OK;
}


```

### Module file

<pre>
$ vim nsTestModule.cpp 
</pre>


### Javascript file

<pre>
$ vim nsTest.js 
</pre>

### manifest file

<pre>
$ vim nsTest.manifest
</pre>


### Building your XPCOM component

<pre>
$ cd MOZ_CEN
$ ./mach build
</pre>


### Testing your XPCOM component in **xpcshell**

<pre>
$ cd obj-YOUR-TARGET-XXXX/dist/bin
$ ./run-mozilla.sh ./xpcshell
</pre>



## Reference
<a name="XPCOM" title="Creating XPCOM components" target="_blank" href="https://developer.mozilla.org/en-US/docs/Mozilla/Tech/XPCOM/Guide/Creating_components">[1] Creating XPCOM components</a>

<a name="" title="" target="_blank" href="">[2] abc</a>

<a name="" title="" target="_blank" href="">[3] abc</a>


## Manuscript
<a title="Google Doc" target="_blank" href="https://docs.google.com/a/mozilla.com/document/d/1rlAnNbVYUnI6PMWjn4eTB_As5tPfYObco9lDNkf8N6E/edit?usp=sharing">click here</a>
